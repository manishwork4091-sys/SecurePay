/**
 * Core Philosophy: This ruleset enforces a strict security model based on user ownership and role-based access control.
 * It ensures that users can only access their own data, while administrators have specific, elevated privileges for system-wide collections.
 *
 * Data Structure: User data is stored in `/users/{userId}`. All transactions are stored in a flat `/transactions` collection, with
 * each document containing a `userId` to enforce ownership. System-level data resides in separate top-level collections.
 *
 * Key Security Decisions:
 * - User Data Isolation: All collections under /users/{userId} are strictly private to the authenticated user matching that userId.
 * - Flat Transaction Structure: Transactions are stored in a top-level collection to allow for scalable queries while still being secured on a per-user basis via a `userId` field.
 * - Administrator Roles: Administrator status is determined by the existence of a document in the /roles_admin/{userId} collection. This collection is not client-accessible and must be managed via the Firebase console or a trusted backend.
 * - Immutable Audit Logs: The /auditLogs collection is read-only for administrators and cannot be written to by any client.
 *
 * Denormalization for Authorization: The /roles_admin/{userId} collection is a key example of denormalization. We perform a performant `exists()` check against this collection to determine admin privileges.
 *
 * Structural Segregation: User-private data (/users) is cleanly separated from shared data (/transactions) and system-level data (/auditLogs, /roles_admin).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * isSignedIn
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * isOwner
     * Checks if the currently authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * isExistingOwner
     * Checks for ownership on an existing document. Used for update and delete.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * isAdmin
     * Checks if the authenticated user has an admin role document.
     * This is a performant check that does not count as a read operation.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * isCreatingOwnUserDocument
     * Validates that the user document being created has an 'id' field
     * that matches the user's auth UID.
     */
    function isCreatingOwnUserDocument(userId) {
      return request.resource.data.id == userId;
    }
    
    /**
     * isRoleImmutable
     * Ensures the role field cannot be changed by the user.
     */
    function isRoleImmutable() {
      return request.resource.data.role == resource.data.role;
    }


    //-------------------------------------------------------------------------
    // Collection Rules
    //-------------------------------------------------------------------------

    /**
     * @description   Stores user profile information. A user can create their own profile
     *                and can only read or write their own data thereafter. Role escalation is prevented.
     * @path          /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && isCreatingOwnUserDocument(userId) && request.resource.data.role == 'user';
      allow update: if isExistingOwner(userId) && isRoleImmutable();
      allow delete: if isExistingOwner(userId);
    }
    
    /**
     * @description   Stores all user transactions in a flat collection.
     *                Access is granted based on the `userId` field within each document.
     * @path          /transactions/{transactionId}
     */
    match /transactions/{transactionId} {
      // A user can create a transaction if the new document's `userId` matches their own.
      allow create: if isOwner(request.resource.data.userId);
      
      // A user can read, update, or delete a transaction if the existing document's `userId` matches their own.
      // The `read` rule also enables `list` queries that include `where('userId', '==', request.auth.uid)`.
      allow get, update, delete, list: if isOwner(resource.data.userId);
    }
    
    /**
     * @description   A collection used to grant admin privileges. The existence of a
     *                document with a user's UID as its ID means they are an admin.
     *                This collection is not readable or writable by any client.
     * @path          /roles_admin/{userId}
     */
    match /roles_admin/{userId} {
      allow get, list, create, update, delete: if false;
    }

    /**
     * @description   Stores system-level audit logs. This data is created by backend
     *                processes and is read-only for administrators.
     * @path          /auditLogs/{auditLogId}
     */
    match /auditLogs/{auditLogId} {
      allow get, list: if isAdmin();
      allow create, update, delete: if false;
    }
  }
}
